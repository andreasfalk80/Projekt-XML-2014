\chapter{XML skema for resource}
\label{chap:XML_skema_for_resource}
\section{Formål}
\label{sec:formaal_skemaet}
Det primære formål med et xml skema, er muligheden for at validere et xml dokument, og på den måde kontrollere at det aftalte format er overholdt. Ofte kan disse skemaer, som i sig selv er xml dokumenter, også bruges til at automatisk generering af kode til behandling af alle de xml dokumenter som er valide i forhold til skemaet. Dette sker typisk gennem tredjeparts software. 
Et xml skema skal beskrive 2 vigtige egenskaber for at opfylde det beskrevne behov. 
\begin{description}
	\item[Struktur] som beskriver forholdet mellem forældre og børn elementer. Her kommer complexType og sequence med flere i spil
	\item[Datatype] som angiver format eller værdisæt for det data der er gemt i elementerne. Her benyttes simpleType og restriction med flere.
\end{description}
Med analyse funktionen fra kapitel \ref{chap:analyse_xml_struktur}, er det nemt at komme igang med at definere et skema, som kan validere strukturen i xml dokumentet. Hvor godt resultatet fra analyse funktionen end er, så er fokus for den primært elementerne og deres indbyrdes forhold til hinanden. Så med den information er grundstrukturen i skemaet klarlagt.
Men resultatet indeholder ikke nogen information om datatyperne, der er svært at fastslå automatisk, da det typisk forudsætter en del domæne viden. Datatyperne vil derfor i høj grad blive udledt udfra deres navne og implicitte betydning. Nogle af begrænsningerne der benyttes i skemaet, er tilføjet udelukkende for at demonstrere flere forskellige typer af begrænsninger, og vil måske ikke være korrekte i XML dokumentets virkelige domæne.

\section{Skemaet \fil{resource.xsd}}
\label{sec:skemaet}

Det endelige skema kan ses i filen \fil{resource.xsd}, samt i bilag XXX *TODO* reference til bilag med hele skemaet *TODO*. Skemaet er opbygget, ved en manuel gennemgang af analyse resultatet i bilag *TODO reference til bilaget*. Hvert element er behandlet, og en type med en passende defintion er oprettet i skemaet. Der er brugt navngivne typer i stor udstrækning, da det øger læsbarheden væsentligt. 

Elementerne i skemaet beskrives her, grupperet udfra hvilke typer og skema 'features' der er benyttet til at definere dem. 
\vspace{1.5mm}
\begin{compactitem}
  \item complexType og sequence.
  \begin{compactitem}
    \item \xmlelm{root}
		\item \xmlelm{resourceType} 
		\item \xmlelm{itemdateType}
		\item \xmlelm{identifierType}
		\item \xmlelm{publisherType}
		\item \xmlelm{imageType}
		\item \xmlelm{interestingfactType}
		\item \xmlelm{resourcekeywordsType}
		\item \xmlelm{subjectsType}
  \end{compactitem}
\end{compactitem}
\vspace{1.5mm}
Typen resourceType er et eksempel på en type der er defineret som en kompleks type, der består af en sekvens af elementer. 
Gældende for en sekvens er at alle elementerne skal optræde i den angivede rækkefølge. Dette er i modsætning til en anden indikator all, hvor om det gælder at elementerne kan optræde i en vilkårlig rækkefølge. 
For hvert element i sekvensen kan der angives kardinalitet, ved brug af indikatorerne minOccurs og maxOccurs. Her er brugt de værdier som analyse funktionen returnerede.

Alle definerede typer, pånær titleType, urlType og primaryType er komplekse typer med en sekvens. Nogle er lavet som navngivede typer, f.eks. resourceType. Mens andre er anonyme typer, som for eksempel typen for elementet keywords, som er defineret i den navngivne type resourcekeywordsType.
%Der må ikke rettes i formattering, så går det galt. Kode bør kopieres over noteblok, for at fjerne ekstra formateringen fra Notepad++
\begin{figure}[ht]
\centering
\begin{BVerbatim} 
<xs:complexType name='resourcekeywordsType'>
  <xs:sequence>
    <xs:element name='keywords'>
      <xs:complexType>
        <xs:sequence>
	  <xs:element name='term' 
                      type='xs:string' 
                      maxOccurs='unbounded'/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
  </xs:sequence>
</xs:complexType>
\end{BVerbatim}
\caption{Eksempel på navngivet og anonym type, der samtidig er kompleks}
\label{code:def_resourcekeywordsType}
\end{figure}
\begin{itemize}
\item[simpleType og restriction] Typen titleType tager udgangspunkt i typen string, men tilføjer en begrænsning på længen af strengen, ved brug af minLength og maxLength. UrlType bruger facetten pattern, til at angive et simpelt format tjek af en url adresse, og den sidste simple type, primaryType bruger facetten enumeration, til at begrænse værdierne til YES og NO.
%Der må ikke rettes i formattering, så går det galt. Kode bør kopieres over noteblok, for at fjerne ekstra formateringen fra Notepad++
\begin{figure}[ht]
\centering
\begin{BVerbatim} 
<xs:simpleType name='urlType'>
  <xs:restriction base='xs:string'>
    <xs:pattern value="((http|https)?://.*)?" />
  </xs:restriction>
</xs:simpleType>
\end{BVerbatim}
\caption{Eksempel på en simpel type, med en begrænsning som anvender et pattern}
\label{code:def_urlType}
\end{figure}

\item[standard typer] Enkelte elementer benytter sig af standard typer, f.eks. ID som defineres som positiveInteger, og description som en string uden begrænsninger, samt recordcreated og placedonline i itemDate, der begge bruger typen date. 
\end{itemize}

Med et skema defineret, kan xml strukturen valideres. Det gøres ved at tilføje en reference til skemaet i rod elementet. I dette projekt er Notepad++ samt pluginet xml tools brugt til at foretage valideringen. Ikke overaskende er strukturen valid i forhold til det nye skema.
\begin{figure}[ht]
\centering
\begin{BVerbatim} 
<root xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
      xsi:noNamespaceSchemaLocation="resource.xsd">
\end{BVerbatim}
\caption{Reference til skema tilføjet i xml}
\label{code:reference_til_skema}
\end{figure}

\section{Konklusion}



