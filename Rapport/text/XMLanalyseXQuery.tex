 \chapter{Analyse af resource}
\label{chap:analyse_xml_struktur}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Formål %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Formål}
\label{sec:Formaal_xml_analyse}
At gennemskue, og udlede strukturen af et xml dokument kan være en stor opgave, især for et komplekst dokument med mange elementer. I tilfældet med resource, som indeholder mange oplysninger for 1741 resourcer, kan strukturen ikke gennemskues ved en simpel gennemlæsning af filen. 
Alternativet kan være at oprette en database i \prg{BaseX}, og ved brug af en række \lang{XQuery} forspørgelser kan der samles nok informationer om elementerne i XML'en, til at kunne beskrive strukturen. På denne måde kan \prg{Basex} hjælpe med at skabe overblik. Men det er stadig en manuel process, hvor der løbende udvikles nye forespørgelser efterhånden som man opbygger kendskab til XML dokumentet, og identificerer nye aspekter der skal undersøges. Figur \ref{xquery:count_empty_image} viser hvordan det kan afgøres om der findes elementer \xmlelm{image} hvor alle dets underelementer er tomme. Hvis man ønsker at lave samme forespørgelse for elementet \xmlelm{itemDate}, så kræver det at man skriver en ny forespørgelse, der minder utroligt meget om den der allerede er udviklet.
\begin{figure}[ht]
\centering
\begin{BVerbatim}
count(//resource/image[url ='' and 
                       caption ='' and 
                       alttext='' and 
                       sourceurl=''])
\end{BVerbatim}
\caption{Forespørgsel der er specielt udviklet til resource}
\label{xquery:count_empty_image}
\end{figure}

Selvom denne fremgangsmåde vil virke, kan der istedet udvikles en mere generel funktion, som behandler dokumentet ud fra generelle betragtninger, og derfor kan bruges for alle XML dokumenter. Sådan en \lang{XQuery} funktion udvikles i dette projekt, så de ønskede metadata for XML strukturen bliver returneret på en strukturet vis. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Brug af BaseX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Brug af BaseX}

Til udvikling af forespørgelser benyttes XML databasen \prg{BaseX 7.7.2}, hvor der oprettes en ny database der tager udgangspunkt i filen \fil{resource.xml}. Der ændres ikke på indstillingerne for oprettelsen, hvilket betyder at der oprettes både Text og Attribut index, for at effektivisere forespørgelserne.

Koden til funktionerne der udvikles findes i filen \fil{Kode/XQuery/XQuery-analyse-funktion.xq}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Design af analyse funktion %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Design af analyse funktioner}
\label{sec:DesignAfAnalyseFunktion}
Der er næsten uendeligt mange aspekter at vurdere i forhold til struktur og datatyper, som kan være interresant at undersøge, og følgende er valgt til dette projekt, da de i lang udstrækning er tilstrækkeligt til at kunne definere et XML skema.
\begin{compactitem}
	\item Element navn
	\item Underelementer.
	\item Kardinaliteten af et element, altså hvor mange gange det kan optræde i dokumentet.
	\item Hvis et element indeholder data, så findes den maksimale længde af datastrengen.
	\item Attributer.
\end{compactitem}
\vspace{1.0mm}
Figur \ref{code:struktur_metadata-xml} viser den XML struktur som de nævnte oplysninger skal præsenteres i. Informationer om et element angives som attributter til elementet \xmlelm{element}, og informationer om dets attributer som \xmlelm{attribute} underelementer. Denne struktur for \xmlelm{element} gentages rekursivt for alle underlementerne. 
\begin{figure}[ht]
\centering
\begin{BVerbatim}
<elements>
 <element name="xmlwithattributes" maxlength="" card="1:1">
  <attribute name="test" maxlength="1"/>
  <element name="node1" maxlength="4" card="1:1">
    <attribute name="part" maxlength="5"/>
  </element>
 </element>
</elements>

baseret på dette:
<xmlwithattributes test="1">
  <node1 part="12345">test</node1>
</xmlwithattributes>
\end{BVerbatim}
\caption{Struktur for genereret metadata-xml, samt analyseret XML}
\label{code:struktur_metadata-xml}
\end{figure}

For \xmlatt{maxlength} gælder det at den kun udfyldes for elementer med en text() node. Virkemåden for \xmlatt{maxlength} er ikke defineret for elementer med mixed-content, og da den pågældende xml resource.xml ikke indeholder mixed-content, bliver dette tilfælde ikke håndteret yderligere.
Attributten \xmlatt{card} udfyldes med notationene \verb|1:1, 0:1, 0:n(v), 1:n(v)| og dækker de normale muligheder for kardinalitet. I parentesen angiver \verb|v|, den største værdi der blev fundet for \verb|n|.

Vær opmærksom på at elementerne behandles i grupper baseret på deres navn og den kontekst de optræder i. Dvs. at kardinalitetten ikke undersøges for et enkelt element \xmlelm{url}, men for alle elementer der har navnet 'url', i den pågældende kontekst.
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Implementation af local:analyze %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation af analyse funktioner}
\label{Implementation_af_analyse_funktioner}

Løsningen struktureres ud i flere funktioner, svarende til en funktion pr. oplysning. Alle implementerede funktioner oprettes i det namespace der hedder local, og navngives derfor f.eks. \funk{local:analyze}, Men i resten af rapporten udelades namespace, og den funktion vil blive refereret til som \funk{analyze}.
\begin{compactitem}
	\item \funk{analyze} er start funktionen der kaldes for at få analyseret en xml struktur.
	\item \funk{analyze2} kaldes af \funk{analyze}, og er en rekursiv funktion der opbygger resultatet. 
	\item \funk{analyze\_attributes} finder alle attributter for et element, samt den maksimale længde af data fundet i attributten.
	\item \funk{analyze\_maxlength} finder den maksimale længde af data fundet i elementet.
	\item \funk{analyze\_card} finder kardinaliteten af elementet
\end{compactitem}
\vspace{1.0mm}
De følgende afsnit vil beskrive de eneklte funktioners implementation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  subsection analyze  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Funktion \funk{analyze}}
\label{funktion_analyze}
Funktionen \funk{analyze} begynder analysen ved input elementets børn, og returnerer derfor ingen oplysninger om selve input elementet. Det betyder at en analyse af et helt xml dokument, eller fragment, bør startes med kaldet \verb|local:analyze(/)|, altså med dokumentroden som parameter. Dette skyldes at f.eks. kardinalitets analysen kræver information om hvilken kontekst elementerne optræder i.

Den eneste funktionalitet der implementeres i denne funktion er at tilføje det yderste \xmlelm{elements} element til resultatet, og initiering af de rekursive kald.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  subsection analyze2  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Funktion \funk{analyze2}}
\label{funktion_analyze2}

Funktionen \funk{analyze2} er den rekursive funktion der reelt behandler xml strukturen. Implementationen er indsat i figur \ref{code:func_analyze2}, og beskrives i det følgende. 
\begin{figure}[ht]
\centering
\begin{BVerbatim}
01: declare function local:analyze2($elements as item()*)
02: as element()*
03: { 
04:    let $names :=  distinct-values($elements/*/name())
05:    for $el in $names 
06:    let $maxlength := local:analyze_maxlength($elements/*[name()=$el])
07:    let $card := local:analyze_card($elements,$el)
08:    return 
09:    <element name='{$el}' maxlength='{$maxlength}' card='{$card}'>
10:        {local:analyze_attributes($elements/*[name()=$el])}
11:        {local:analyze2($elements/*[name()=$el])}
12:    </element>
13: };
\end{BVerbatim}
\caption{Den rekursive funktion analyze2}
\label{code:func_analyze2}
\end{figure}

Alle tags med samme navn i den nuværende kontekst behandles og analyseres samlet, og derfor grupperes disse ved at opbygge en liste af unikke elementnavne i linie \lref{04}. For hvert af navnene gemmes resultatet af \funk{analyze\_maxlength} og \funk{analyze\_card} i to variable. Brugen af variable sker udelukkende for at øge læsbarheden af opbygningen af \xmlelm{element} i linie \lref{09}. Attributter behandles i linie \lref{10}, hvor der opbygges et \xmlelm{attribut} element for hver atribut fundet. Tilsidst foretages det rekursive kald til \funk{analyze2}, som sørger for at opbygge \xmlelm{element} for det næste niveau.

Et eksempel kan måske bedst illustrere, hvad det er der leveres til funktionerne som input, for det er vigtigt at have  styr på den del. 

Hvis \funk{analyze2} kaldes med \xmlelm{root} elementet, kommer variablen \$names til at indeholde en liste med et element, nemlig strengen 'resource', da det er det eneste element der er under \xmlelm{root}. Ved kald til f.eks. \funk{analyze\_maxlength}, kan man i linie \lref{06} se at input er givet ved en forespørgelse, som finder alle de underelementer til \xmlelm{root}, som hedder \$el, i vores tilfælde er det strengen 'resource'. Så der er kun et kald til \funk{analyze\_maxlength} i dette eksmpel, til gengæld er inputtet til funktionen,  mængden af alle \xmlelm{resource} elementerne. 

Funktionen skal jo netop indsamle generelle oplysninger på tværs af alle 'ens' elementer, og dette kan kun ske, hvis man betragter mængder af elementer. 

De andre funktionskald, foregår på samme måde, pånær for \funk{analyze\_card}, der har behov for et andet input. Det beskrives nærmere i afsnit \ref{subsec:analyze_card}. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  subsection analyze_attributes  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Funktion \funk{analyze\_attributes}}
\label{subsec:analyze_attributes}

Ud fra mængden af elementer som bliver givet som input bliver der i linie \lref{04} fundet de unikke navne for hver attribut, og i line \lref{06} bliver længden af hver atribut fundet, og tilsidst bliver den maksimale værdi fundet sat ind som en del af resultatet. Koden kan ses i figur \ref{code:func_analyze_attributes}.
\begin{figure}[ht]
\centering
\begin{BVerbatim}
01: declare function local:analyze_attributes($elements as item()*)
02: as element()*
03: { 
04:   for $att in distinct-values($elements/@*/name())
05:     return <attribute name='{$att}' maxlength=
06:       '{max($elements/@*[name() = $att]/string-length())}'/>
07: };
\end{BVerbatim}
\caption{Funktionen analyze\_attributes}
\label{code:func_analyze_attributes}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  subsection analyze_maxlength  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Funktion \funk{analyze\_maxlength}}
\label{subsec:analyze_maxlength}

Funktionen finder den maksimale længde, på nøjagtig samme måde som funktionen \funk{analyze\_attributes}, dog returneres der kun en værdi hvis der findes text i elementet.
%\begin{figure}[ht]
%\centering
%\begin{BVerbatim}
%01: declare function local:analyze_maxlength($elements as item()*)
%02: as xs:string
%03: { 
%04:   if($elements/text()) 
%05:     then string(max($elements/text()/string-length())) 
%06:     else ''
%07: };
%\end{BVerbatim}
%\caption{Funktionen analyze\_maxlength}
%\label{code:func_analyze_maxlength}
%\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  subsection analyze_card %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Funktion \funk{analyze\_card}}
\label{subsec:analyze_card}

Som nævnt har denne funktion brug for mere input, da konteksten er vigtig for at kunne bestemme kardinaliteten. Hvis funktionen kaldes med en mængde \xmlelm{resource} elementer, kan kardinaliteten for \xmlelm{resource} ikke bestemmes, da det ikke kan afgøres hvilke elementer der har samme forælder. 

Hvis vi kigger på eksemplet fra afsnit \ref{funktion_analyze2}, betyder det at funktionen kaldes med \xmlelm{root} i \$parent og 'resource' i child\_name. En vigtig pointe er at der kaldes med hele mængden af alle de mulige forældre, og derfor kan funktionen også bestemme om et element er valgfrit eller obligatorisk.

\begin{figure}[ht]
\centering
\begin{BVerbatim}
01: declare function local:analyze_card($parents as item()*,$child_name as xs:string)
02: as xs:string
03: { 
04:   let $child_count := $parents/count(*[name()=$child_name])
05:   let $min := min($child_count)
06:   let $max := max($child_count)
07:   let $result := 
08:     if($min = 1 and $max = 1) then '1:1' else
09:     if($min = 0 and $max = 1) then '0:1' else
10:     if($min = 0 and $max > 1) then concat('0:n','(',$max,')') else 
11:     if($min > 0 and $max > 1) then concat('1:n','(',$max,')') else 'ERROR' 
12:   return $result
};
\end{BVerbatim}
\caption{Funktionen analyze\_card}
\label{code:func_analyze_card}
\end{figure}

Koden i linie \lref{04} tæller antallet af underelementer, for hvert enkelt forælder element. Derfor indeholder variablen \$child\_count en mængde af resultater af count, et resultat for hver forælder. Den mindste og største værdi kan nu findes, og bruges til at opsættes resultatet på den ønskede form.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  section konklusion %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Konklusion}
\label{sec:konklusion_xml_analyse}
Funktionen der finder attributter har vist sig at have en enkelt mangel, da det ikke bestemmes om en attribut er valgfri, og derfor kan resultatet ikke benyttes til at definere et XML skema udfra. Men da analysen har vist at resource ikke indeholder attributter implementeres denne udvidelse ikke, da den eksisterende funktionalitet er dækkende for det nuværende behov.

Så med disse funktioner er det nu muligt, på en simpel og let måde, at skabe et overblik over strukturen for et vilkårligt XML dokument. Resultatet for dokumentet resource kan ses i bilag \ref{app:Genereret analyse af resource.xml}. 
