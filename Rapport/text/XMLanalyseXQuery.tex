 \chapter{Analyse af resource}
\label{chap:analyse_xml_struktur}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Formål %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Formål}
\label{sec:Formaal_xml_analyse}
At gennemskue, og udlede strukturen af et xml dokument kan være en stor opgave, især for et stort dokument med mange elementer. I tilfældet med resource, som indeholder utroligt meget data, kan strukturen ikke gennemskues ved en simpel gennemlæsning af filen. 
Alternativet kan være at oprette en database i \prg{BaseX}, og ved brug af en række \lang{XQuery} forspørgelser kan der samles nok informationer om elementerne i xml'en, til at kunne beskrive strukturen. På denne måde kan \prg{Basex} hjælpe med at skabe overblik. Men det er stadig være en manuel process, hvor der løbende udvikles nye forespørgelser efterhånden som man opbygger kendskab til XML dokumentet. Figur \ref{xquery:count_empty_image} viser hvordan det kan afgøres om der findes elementer \xmlelm{image} hvor alle dets underelementer er tomme. Hvis man ønsker at lave samme forespørgelse for elementet \xmlelm{itemDate}, så kræver det at man skriver en helt ny forespørgelse.
\begin{figure}[ht]
\centering
\begin{BVerbatim}
count(//resource/image[url ='' and 
                       caption ='' and 
                       alttext='' and 
                       sourceurl=''])
\end{BVerbatim}
\caption{Forespørgsel der er specielt udviklet til resource}
\label{xquery:count_empty_image}
\end{figure}

Der kan istedet udvikles en mere generel funktion, som behandler dokumentet ud fra generelle betragtninger, og derfor kan bruges for alle XML dokumenter. Denne \lang{XQuery} funktion udvikles, så de ønskede metadata for xml strukturen bliver returneret på en strukturet vis. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Brug af BaseX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Brug af BaseX}

Til udvikling af forespørgelser benyttes XML databasen \prg{BaseX 7.7.2}, hvor der oprettes en ny database der tager udgangspunkt i filen \fil{resource.xml}. Der ændres ikke på indstillingerne for oprettelsen, hvilket betyder at der oprettes både Text og Attribut index, for at effektivisere forespørgelserne.

Koden til funktionerne der udvikles til analyse af et xml dokument findes mappen \fil{Kode/XQuery} i filen \fil{XML analyse funktioner XQuery.xq}, og kan ses i bilag *TODO* indsæt bilag *TODO*


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Design af analyse funktion %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Design af analyse funktioner}
\label{sec:DesignAfAnalyseFunktion}

Der er næsten uendeligt mange aspekter at vurdere i forhold til struktur og datatyper, som kan være interresant at undersøge, og følgende er valgt til denne rapport, da de i lang udstrækning er tilstrækkeligt til at kunne definere et XML skema.
\begin{itemize}
	\item Element navn
	\item Underelementer.
	\item Kardinaliteten af et element, altså hvor mange gange det kan optræde i dokumentet.
	\item Hvis et element indeholder data, så findes den maksimale længde af datastrengen.
	\item Attributer.
\end{itemize}
Figur \ref{code:struktur_metadata-xml} viser den XML struktur som funktionen skal resultere i. Informationer om et element angives som attributter til elementet \xmlelm{element}, og informationer om dets attributer som \xmlelm{attribute} underelementer. Denne struktur for \xmlelm{element} gentages rekursivt for alle underlementerne. 
**HUSK** eksempel som bilag hvor der rent faktisk er attributter. **HUSK**
\begin{figure}[ht]
\centering
\begin{BVerbatim}
<elements>
  <element name="" maxlength="" card="">
      <attribute name=""/>
    <element name="" maxlength="" card=""/>
	</element>
</elements>
\end{BVerbatim}
\caption{Struktur for genereret metadata-xml}
\label{code:struktur_metadata-xml}
\end{figure}
For \xmlatt{maxlength} gælder det at den kun udfyldes for elementer med en text() node. Virkemåden for \xmlatt{maxlength} er ikke defineret for elementer med mixed-content, og da den pågældende xml resource.xml ikke indeholder mixed-content, bliver dette tilfælde ikke håndteret yderligere.
Attributten \xmlatt{card} udfyldes med notationene \verb|1:1, 0:1, 0:n(v), 1:n(v)| og dækker de normale muligheder for kardinalitet. I parentesen angiver \verb|v|, den største værdi der blev fundet for \verb|n|.

Vær opmærksom på at elementerne behandles i grupper baseret på deres navn og den kontekst de optræder i. Dvs. at kardinalitetten ikke undersøges for et enkelt element \xmlelm{url}, men for alle elementer der har navnet 'url', i den pågældende kontekst.
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Implementation af local:analyze %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation af analyse funktioner}
\label{Implementation_af_analyse_funktioner}

Løsningen struktureres ud i flere funktioner, svarende til en funktion pr. oplysning. Alle implementerede funktioner oprettes i det namespace der hedder local, og navngives derfor f.eks. \funk{local:analyze}, Men i resten af rapporten udelades namespace, og den funktion vil blive refereret til som \funk{analyze}.
\begin{itemize}
	\item \funk{analyze} er start funktionen der kaldes for at få analyseret en xml struktur.
	\item \funk{analyze2} kaldes af \funk{analyze}, og er en rekursiv funktion der opbygger resultatet. 
	\item \funk{analyze\_attributes} finder alle attributter for et element, samt den maksimale længde af data fundet i attributten.
	\item \funk{analyze\_maxlength} finder den maksimale længde af data fundet i elementet.
	\item \funk{analyze\_card} finder kardinaliteten af elementet
\end{itemize}

%Til at opbygge XML'en med metadata, udnyttes \lang{XQuery}'s gode understøttelse af at generere xml som resultat af en forespørgelse.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  subsection analyze  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Funktion \funk{analyze}}
\label{funktion_analyze}
Funktionen \funk{analyze} begynder analysen ved input elementets børn, og returnerer derfor ingen oplysninger om input elementet. Det betyder at en analyse af et helt xml dokument, eller fragment, bør startes med kaldet \verb|local:analyze(/)|, altså med dokumentroden som parameter. Dette skyldes at f.eks. kardinalitets analysen kræver information om hvilken kontekst elementerne optræder i.

Den eneste funktionalitet der implementeres i denne funktion er at tilføje det yderste \xmlelm{elements} element til resultatet.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  subsection analyze2  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Funktion \funk{analyze2}}
\label{funktion_analyze2}

Funktionen \funk{analyze2} er den rekursive funktion der reelt behandler xml strukturen. Implementationen er indsat i figur \ref{code:func_analyze2}, og beskrives i det følgende. 
\begin{figure}[ht]
\centering
\begin{BVerbatim}
01: declare function local:analyze2($elements as item()*)
02: as element()*
03: { 
04:    let $names :=  distinct-values($elements/*/name())
05:    for $el in $names 
06:    let $maxlength := local:analyze_maxlength($elements/*[name()=$el])
07:    let $card := local:analyze_card($elements,$el)
08:    return 
09:    <element name='{$el}' maxlength='{$maxlength}' card='{$card}'>
10:        {local:analyze_attributes($elements/*[name()=$el])}
11:        {local:analyze2($elements/*[name()=$el])}
12:    </element>
13: };
\end{BVerbatim}
\caption{Den rekursive funktion analyze2}
\label{code:func_analyze2}
\end{figure}

Alle tags med samme navn i den nuværende kontekst behandles og analyseres samlet, og derfor grupperes disse ved at opbygge en liste af unikke elementnavne i linie \lref{04}. For hvert af navnene gemmes resultatet af \funk{analyze\_maxlength} og \funk{analyze\_card} i to variable, for at øge læsbarheden af opbygningen af \xmlelm{element} i linie \lref{09}. Attributter behandles i linie \lref{10}, hvor der opbygges et \xmlelm{attribut} element for hver atribut fundet. Tilsidst foretages det rekursive kald til \funk{analyze2}, som sørger for at opbygge \xmlelm{element} for det næste niveau.

Det er vigtigt at forstå hvad det er for en størrelse som leveres til funktionerne som input, og det illustreres bedst med et eksempel. Hvis \funk{analyze2} kaldes med \xmlelm{root} elementet, kommer variablen \$names til at indeholde strengen 'resource', da det er det eneste element der er under \xmlelm{root}. Ved kald til f.eks. \funk{analyze\_maxlength}, kan man i linie \lref{06} se at input er givet ved en forespørgelse, som finder alle de underelementer til \xmlelm{root}, som hedder \$el, i vores tilfælde er det strengen 'resource'. Og det er denne mængde af elementer, der bliver behandlet videre i de kaldte funktioner. 
Funktionen \funk{analyze\_card} har behov for et andet input og det beskrives nærmere i afsnit \ref{subsec:analyze_card}. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  subsection analyze_attributes  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Funktion \funk{analyze\_attributes}}
\label{subsec:analyze_attributes}

Ud fra mængden af elementer som bliver givet som input bliver der i linie \lref{04} fundet de unikke navne for hver attribut, og i line \lref{06} bliver længden af hver atribut fundet, og tilsidst bliver den maksimale værdi fundet sat ind som en del af resultatet. Koden kan ses i figur \ref{code:func_analyze_attributes}.
\begin{figure}[ht]
\centering
\begin{BVerbatim}
01: declare function local:analyze_attributes($elements as item()*)
02: as element()*
03: { 
04:   for $att in distinct-values($elements/@*/name())
05:     return <attribute name='{$att}' maxlength=
06:       '{max($elements/@*[name() = $att]/string-length())}'/>
07: };
\end{BVerbatim}
\caption{Funktionen analyze\_attributes}
\label{code:func_analyze_attributes}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  subsection analyze_maxlength  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Funktion \funk{analyze\_maxlength}}
\label{subsec:analyze_maxlength}

Funktionen finder den maksimale længde, på nøjagtig samme måde som funktionen \funk{analyze\_attributes}, dog returneres der kun en værdi hvis der findes text i elementet.
%\begin{figure}[ht]
%\centering
%\begin{BVerbatim}
%01: declare function local:analyze_maxlength($elements as item()*)
%02: as xs:string
%03: { 
%04:   if($elements/text()) 
%05:     then string(max($elements/text()/string-length())) 
%06:     else ''
%07: };
%\end{BVerbatim}
%\caption{Funktionen analyze\_maxlength}
%\label{code:func_analyze_maxlength}
%\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  subsection analyze_card %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Funktion \funk{analyze\_card}}
\label{subsec:analyze_card}

Som nævnt har denne funktion brug for mere input, da konteksten er vigtig for at kunne bestemme kardinaliteten. Hvis funktionen kaldes med en mængde \xmlelm{resource} elementer, kan kardinaliteten for \xmlelm{resource} ikke bestemmes, da det ikke kan afgøres hvilke elementer der har samme forælder. 

Hvis vi kigger på eksemplet fra afsnit \ref{funktion_analyze2}, betyder det at funktionen kaldes med \xmlelm{root} i \$parent og 'resource' i child\_name. En vigtig pointe er at der kaldes med hele mængden af alle de mulige forældre, og derfor kan funktionen også bestemme om et element er valgfrit eller obligatorisk.

\begin{figure}[ht]
\centering
\begin{BVerbatim}
01: declare function local:analyze_card($parents as item()*,$child_name as xs:string)
02: as xs:string
03: { 
04:   let $child_count := $parents/count(*[name()=$child_name])
05:   let $min := min($child_count)
06:   let $max := max($child_count)
07:   let $result := 
08:     if($min = 1 and $max = 1) then '1:1' else
09:     if($min = 0 and $max = 1) then '0:1' else
10:     if($min = 0 and $max > 1) then concat('0:n','(',$max,')') else 
11:     if($min > 0 and $max > 1) then concat('1:n','(',$max,')') else 'ERROR' 
12:   return $result
};
\end{BVerbatim}
\caption{Funktionen analyze\_card}
\label{code:func_analyze_card}
\end{figure}

Koden i linie \lref{04} tæller antallet af underelementer, for hvert enkelt forælder element. Derfor indeholder variablen \$child\_count en mængde af resultater af count, et resultat for hver forælder. Den mindste og største værdi kan nu findes, og bruges til at opsættes resultatet på den ønskede form.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  section konklusion %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Konklusion}
\label{sec:konklusion_xml_analyse}



